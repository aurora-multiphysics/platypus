#include "mfem.hpp"
#include <fstream>
#include <iostream>

using namespace std;
using namespace mfem;

/*****************************************\
! Nonlinear functions
!
! A non-linear function that is used to
! generate the evaluations in the non-linear
! grid-function-coefficient
!
\*****************************************/
static const double alpha = -0.5;
double  f(const double & u, const Vector & x){ return exp(alpha*u); }
double df(const double & u, const Vector & x){ return alpha*exp(alpha*u); }


/*****************************************\
! Nonlinear Grid function Coefficient
!
! A non-linear gridfunction coefficient
! that varies with, space time and 
! Gfunction value.
!
\*****************************************/
class NonlinearGridFuncCoefficient : public Coefficient
{
   GridFunction &gf;
   function<double(const double &, const Vector &)>                GFunction;
   function<double(const double &, const Vector &, const double)>  TDGFunction;
public:
   NonlinearGridFuncCoefficient(GridFunction &gf_
                      , function<double(const double &, const Vector &)> foo)
                      : gf(gf_), GFunction( move(foo) ) {};

   NonlinearGridFuncCoefficient(GridFunction & gf_
                      , function<double(const double &, const Vector &, const double)> foo)
                      : gf(gf_), TDGFunction( move(foo) ) {};

    double Eval(ElementTransformation &T, const IntegrationPoint &ip)
    {
      double x[3];
      Vector transip(x, 3);
      T.Transform(ip, transip);
      return (GFunction)? GFunction(gf.GetValue(T, ip), transip) 
                        : TDGFunction(gf.GetValue(T, ip), transip, GetTime() );
    }
};

/*****************************************\
! My non-linear form
!
! Singularly non-linear test problem
! c(u)u  + Laplacian (u) - f = R(u)
! dc(u)M + Laplacian = Jac(u)
\*****************************************/
class SohailsNLForm: public Operator{
  private:
    ParFiniteElementSpace &fes;
    mutable ParGridFunction x_gf, b_gf;
    Array<int> dofs;

    //Forms the coefficients
    NonlinearGridFuncCoefficient cf, dcf;
    GradientGridFunctionCoefficient gradCf;

    mutable ParLinearForm   *Residual=NULL; 
    mutable ParBilinearForm *Jacobian=NULL;
    mutable OperatorHandle GradR;
    Solver *Precon;
  public:
    SohailsNLForm(ParFiniteElementSpace & fes, Array<int> BDR_tags);

    // Required to use the native newton solver
    virtual void Mult(const Vector &k, Vector &y) const override;   //Residual Vector
    virtual Operator &GetGradient(const Vector &xp) const override; //Jacobian Matrix
};

/*****************************************\
!  Constructs the non-linear
!  form problem class
\*****************************************/
SohailsNLForm::SohailsNLForm(ParFiniteElementSpace & fes_, Array<int> BDR_tags):
						     fes(fes_), x_gf(&fes), b_gf(&fes)
						   , gradCf(&x_gf), cf(x_gf,f), dcf(x_gf,df), Operator(fes_.TrueVSize())
{
  //Get the constrained boundary dofs
  fes.GetEssentialTrueDofs(BDR_tags, dofs);

  //Forms the residual vector
  Residual = new ParLinearForm(&fes);
  Residual->AddDomainIntegrator(new DomainLFIntegrator(cf));
  Residual->AddDomainIntegrator(new DomainLFGradIntegrator(gradCf));
  Residual->UseFastAssembly(true);
   
  //Forms the Jacobian matrix which is the
  //gradient of the residual
  Jacobian = new ParBilinearForm(&fes);
  Jacobian->AddDomainIntegrator(new MassIntegrator(dcf) );
  Jacobian->AddDomainIntegrator(new DiffusionIntegrator );
}; 


/*****************************************
! R = b - F(x)
! Grad(R)_x = A
!
! f(u) + grad(u).grad(u) = 0 = R(u)
! f'(u) M + grad(u).grad() = J(u)
!
! Constructs/updates the residual form
! which is basically a glorified
! linear form, then updates the Jacobian
! (glorified bilinear form)
\*****************************************/
void SohailsNLForm::Mult(const Vector & x, Vector & r) const{
   //Update the residual vector
   x_gf.Distribute(&x);
   Residual->Assemble();
   Residual->ParallelAssemble(b_gf);
   r = b_gf;

   //Apply the Dirch BCs elimination
   r.SetSubVector(dofs, 0.00);

   //Update the Jacobian for linear-solve
   Jacobian->Update();
   Jacobian->Assemble();
   Jacobian->FormSystemMatrix(dofs, GradR);
};

/*****************************************\
! Passes a handle to the operator
! that is generated by bilinear form
! effectively giving a handle to the
! Jacobian matrix
\*****************************************/
Operator &SohailsNLForm::GetGradient(const Vector &xp) const{
  return *GradR;
};


/*****************************************\
! A main function to test the functionality
! of my newly made non-linear-form class
! and non-linear function of Grid-function
! coefficient
!
\*****************************************/
int main(int argc, char *argv[])
{
   Mpi::Init();
   Hypre::Init();

   // 1. Parse command line options
   const char *mesh_file = "mesh/star.mesh";
   int order = 1;

   OptionsParser args(argc, argv);
   args.AddOption(&mesh_file, "-m", "--mesh", "Mesh file to use.");
   args.AddOption(&order, "-o", "--order", "Finite element polynomial degree");
   args.ParseCheck();

   // 2. Read the mesh from the given mesh file, and refine once uniformly.
   Mesh mesh(mesh_file);
   mesh.UniformRefinement();
   ParMesh pmesh(MPI_COMM_WORLD, mesh);
   {
      int par_ref_levels = 4;
      for (int l=0; l < par_ref_levels; l++) pmesh.UniformRefinement();
   }

   // 3. Define a finite element space on the mesh. Here we use H1 continuous
   //    high-order Lagrange finite elements of the given order.
   H1_FECollection fec(order, mesh.Dimension());
   ParFiniteElementSpace fespace(&pmesh, &fec);
   cout << "Number of DOFs: " << fespace.GetTrueVSize() << endl;

   // 4. Extract the list of all the boundaries. These will be marked as
   //    Dirichlet in order to enforce zero boundary conditions.
   Array<int> ess_bdr(pmesh.bdr_attributes.Max());
   ess_bdr = 1;

   // 5. Define the solution x as a finite element grid function in fespace. Set
   //    the initial guess to zero, which also sets the boundary conditions.
   ParGridFunction x(&fespace);
   x = 0.0;

   // 8. Get true dof vectors and set essential BCs on rhs.
   Vector X(fespace.GetTrueVSize()), B(fespace.GetTrueVSize());
   ParGridFunction U_sol(&fespace), B_vec(&fespace);
   SohailsNLForm sampleProb(fespace, ess_bdr);

   // 9. Set up the Newton solver. Each Newton iteration requires a linear
   //    solve. Here we use Conjugate Gradients to solve the linear system

   //Set-up the linear solve+preconditioner
   CGSolver solver(MPI_COMM_WORLD);
   HypreBoomerAMG *LPrecon = new HypreBoomerAMG;
   LPrecon->SetInterpolation(6);
   LPrecon->SetCoarsening(8);
   LPrecon->SetRelaxType(6);
   LPrecon->SetCycleNumSweeps(1,1);
   LPrecon->SetCycleType(2);
   solver.SetPreconditioner(*LPrecon);

 
   //Set-up the Newton-Solver
   NewtonSolver newton(MPI_COMM_WORLD);
   newton.SetOperator(sampleProb);
   newton.SetSolver(solver);
   newton.SetPrintLevel(1);
   newton.SetRelTol(1e-10);
   newton.SetMaxIter(20);

   // 10. Solve the nonlinear system.
   B_vec = 0.0;
   newton.Mult(B_vec, U_sol);


   // 11. Output for ParaView visualisation.
   {
      ParaViewDataCollection pd("Diffusion", &pmesh);
      pd.SetPrefixPath("ParaView");
      pd.RegisterField("solution", &U_sol);
      pd.SetLevelsOfDetail(order);
      pd.SetDataFormat(VTKFormat::BINARY);
      pd.SetHighOrderOutput(true);
      pd.SetCycle(0);
      pd.SetTime(0.0);
      pd.Save();
   }
   return 0;
}